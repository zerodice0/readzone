# 07. í”„ë¡œí•„ í˜ì´ì§€ êµ¬í˜„ ìš”êµ¬ì‚¬í•­

## í˜ì´ì§€ ì •ë³´
- **ê²½ë¡œ**: `/profile/[userId]`
- **ìš°ì„ ìˆœìœ„**: 2ìˆœìœ„ (Core Features)
- **ì„¤ëª…**: ì‚¬ìš©ì í”„ë¡œí•„ ì •ë³´, í™œë™ í†µê³„, íŒ”ë¡œìš° ê¸°ëŠ¥
- **ì¸ì¦**: ë¹„ë¡œê·¸ì¸ ì ‘ê·¼ ê°€ëŠ¥, ìƒí˜¸ì‘ìš© ì‹œ ë¡œê·¸ì¸ í•„ìš”

## ğŸ“‹ ì°¸ì¡° ë¬¸ì„œ

### ì‚¬ìš©ì í”Œë¡œìš°
- **[í”„ë¡œí•„ ê´€ë¦¬](../user-flows/profile-management.md)** - í”„ë¡œí•„ í¸ì§‘, í”„ë¡œí•„ ì‚¬ì§„, ê³„ì • ì‚­ì œ
- **[ì†Œì…œ ìƒí˜¸ì‘ìš©](../user-flows/social-interaction.md)** - íŒ”ë¡œìš°, ì–¸íŒ”ë¡œìš°, í”„ë¡œí•„ íƒìƒ‰
- **[ì˜¤ë¥˜ ì²˜ë¦¬](../user-flows/error-handling.md)** - í”„ë¡œí•„ ë¡œë”© ì‹¤íŒ¨, ê¶Œí•œ ì˜¤ë¥˜

### í”„ë¡œì íŠ¸ êµ¬ì¡°
- **[êµ¬í˜„ í˜ì´ì§€ ëª©ë¡](../implementation-pages.md)** - í”„ë¡œí•„ì˜ ì‚¬ìš©ì ê´€ë¦¬ ì²´ì¸
- **[ì‚¬ìš©ì íë¦„ë„ ê°œìš”](../user-flows.md)** - í”„ë¡œí•„ ë° í™œë™ ê´€ë¦¬ íë¦„

### ê´€ë ¨ PRD ë¬¸ì„œ
- **[ì„¤ì • í˜ì´ì§€](./08-settings.md)** - í”„ë¡œí•„ í¸ì§‘ê³¼ ê³„ì • ì„¤ì •
- **[ë…í›„ê° ìƒì„¸ í˜ì´ì§€](./05-review-detail.md)** - ì‘ì„±ì í”„ë¡œí•„ ì—°ê²°
- **[ë©”ì¸ í”¼ë“œ í˜ì´ì§€](./01-main-feed.md)** - ì‚¬ìš©ì í”„ë¡œí•„ í´ë¦­ ì§„ì…ì 
- **[ì•Œë¦¼ í˜ì´ì§€](./10-notifications.md)** - íŒ”ë¡œìš° ì•Œë¦¼ ì‹œìŠ¤í…œ
- **[ì‹ ê³ /ì°¨ë‹¨ ê´€ë¦¬ í˜ì´ì§€](./13-moderation.md)** - ì‚¬ìš©ì ì°¨ë‹¨ ê¸°ëŠ¥

## í•µì‹¬ ê¸°ëŠ¥

### 1. í”„ë¡œí•„ ì •ë³´ í‘œì‹œ
- **ê¸°ë³¸ ì •ë³´**: í”„ë¡œí•„ ì‚¬ì§„, ë‹‰ë„¤ì„, ìê¸°ì†Œê°œ, ê°€ì…ì¼
- **í™œë™ í†µê³„**: ë…í›„ê° ìˆ˜, ì¢‹ì•„ìš” ë°›ì€ ìˆ˜, íŒ”ë¡œì›Œ/íŒ”ë¡œì‰ ìˆ˜
- **ì†Œì…œ ë§í¬**: ê°œì¸ ë¸”ë¡œê·¸, SNS ê³„ì • (ì„ íƒì‚¬í•­)
- **ë°°ì§€ ì‹œìŠ¤í…œ**: í™œë™ ìˆ˜ì¤€ë³„ ë°°ì§€ í‘œì‹œ

### 2. ì½˜í…ì¸  íƒ­ ì‹œìŠ¤í…œ
- **ë…í›„ê° íƒ­**: ì‘ì„±í•œ ë…í›„ê° ëª©ë¡ (ìµœì‹ ìˆœ/ì¸ê¸°ìˆœ)
- **ì¢‹ì•„ìš” íƒ­**: ì¢‹ì•„ìš”í•œ ë…í›„ê° ëª©ë¡ (ë³¸ì¸ë§Œ ë³¼ ìˆ˜ ìˆìŒ)
- **ì„œì¬ íƒ­**: ì½ì€ ì±… ëª©ë¡ê³¼ í‰ê°€
- **íŒ”ë¡œì‰/íŒ”ë¡œì›Œ íƒ­**: íŒ”ë¡œìš° ê´€ê³„ ëª©ë¡

### 3. íŒ”ë¡œìš° ì‹œìŠ¤í…œ
- **íŒ”ë¡œìš°/ì–¸íŒ”ë¡œìš° ë²„íŠ¼**: ì‹¤ì‹œê°„ ìƒíƒœ ì—…ë°ì´íŠ¸
- **ìƒí˜¸ íŒ”ë¡œìš° í‘œì‹œ**: "ì„œë¡œ íŒ”ë¡œìš°" ë°°ì§€
- **íŒ”ë¡œìš° ì¶”ì²œ**: ìœ ì‚¬í•œ ì·¨í–¥ ì‚¬ìš©ì ì¶”ì²œ
- **ë³¸ì¸ í”„ë¡œí•„**: ìˆ˜ì •í•˜ê¸° ë²„íŠ¼ í‘œì‹œ

### 4. í”„ë¡œí•„ í¸ì§‘ (ë³¸ì¸ë§Œ)
- **ê¸°ë³¸ ì •ë³´ ìˆ˜ì •**: ë‹‰ë„¤ì„, ìê¸°ì†Œê°œ, ì†Œì…œ ë§í¬
- **í”„ë¡œí•„ ì‚¬ì§„ ë³€ê²½**: ì—…ë¡œë“œ, í¬ë¡­, í¸ì§‘
- **ê°œì¸ì •ë³´ ì„¤ì •**: ì´ë©”ì¼ ê³µê°œ/ë¹„ê³µê°œ, í™œë™ ê³µê°œ ë²”ìœ„

## í•„ìš”í•œ API

### GET `/api/users/[userId]`
```typescript
interface UserProfileRequest {
  userId: string;
  includeStats?: boolean;
  includeActivity?: boolean;
}

interface UserProfileResponse {
  user: {
    id: string;
    username: string;
    bio?: string;
    profileImage?: string;
    socialLinks?: {
      blog?: string;
      twitter?: string;
      instagram?: string;
    };
    joinedAt: string;
    
    stats: {
      reviewCount: number;
      likesReceived: number;
      followerCount: number;
      followingCount: number;
      booksRead: number;
    };
    
    badges: Array<{
      id: string;
      name: string;
      description: string;
      icon: string;
      earnedAt: string;
    }>;
    
    recentActivity: {
      lastReviewAt?: string;
      lastActiveAt: string;
      streakDays: number;
    };
  };
  
  relationship?: {
    isFollowing: boolean;
    isFollowedBy: boolean;
    isMutualFollow: boolean;
  }; // ë¡œê·¸ì¸ ì‚¬ìš©ìë§Œ
  
  isOwner: boolean;
}
```

### GET `/api/users/[userId]/reviews`
```typescript
interface UserReviewsRequest {
  userId: string;
  sort?: 'newest' | 'oldest' | 'popular';
  visibility?: 'public' | 'followers' | 'private';
  cursor?: string;
  limit?: number;
}

interface UserReviewsResponse {
  reviews: ReviewSummary[];
  pagination: {
    nextCursor?: string;
    hasMore: boolean;
    total: number;
  };
}

interface ReviewSummary {
  id: string;
  content: string; // ë¯¸ë¦¬ë³´ê¸° 150ì
  rating: 'recommend' | 'not_recommend';
  tags: string[];
  createdAt: string;
  visibility: 'public' | 'followers' | 'private';
  
  book: {
    id: string;
    title: string;
    author: string;
    coverImage?: string;
  };
  
  stats: {
    likes: number;
    comments: number;
    shares: number;
  };
}
```

### GET `/api/users/[userId]/likes`
```typescript
interface UserLikesRequest {
  userId: string;
  cursor?: string;
  limit?: number;
}

interface UserLikesResponse {
  reviews: Array<{
    id: string;
    likedAt: string;
    review: ReviewSummary;
  }>;
  pagination: {
    nextCursor?: string;
    hasMore: boolean;
    total: number;
  };
}
```

### GET `/api/users/[userId]/books`
```typescript
interface UserBooksRequest {
  userId: string;
  status?: 'read' | 'reading' | 'want_to_read';
  sort?: 'recent' | 'title' | 'rating';
  cursor?: string;
  limit?: number;
}

interface UserBooksResponse {
  books: Array<{
    id: string;
    status: 'read' | 'reading' | 'want_to_read';
    rating?: 'recommend' | 'not_recommend';
    readAt?: string;
    addedAt: string;
    
    book: {
      id: string;
      title: string;
      author: string;
      coverImage?: string;
      publishedDate: string;
    };
    
    reviewId?: string; // ë…í›„ê° ì‘ì„±í•œ ê²½ìš°
  }>;
  
  pagination: {
    nextCursor?: string;
    hasMore: boolean;
    total: number;
  };
  
  summary: {
    totalBooks: number;
    readBooks: number;
    readingBooks: number;
    wantToReadBooks: number;
  };
}
```

### GET `/api/users/[userId]/follows`
```typescript
interface UserFollowsRequest {
  userId: string;
  type: 'followers' | 'following';
  cursor?: string;
  limit?: number;
}

interface UserFollowsResponse {
  users: Array<{
    id: string;
    username: string;
    profileImage?: string;
    bio?: string;
    followedAt: string;
    
    stats: {
      reviewCount: number;
      followerCount: number;
    };
    
    relationship?: {
      isFollowing: boolean;
      isFollowedBy: boolean;
    }; // ë¡œê·¸ì¸ ì‚¬ìš©ìë§Œ
  }>;
  
  pagination: {
    nextCursor?: string;
    hasMore: boolean;
    total: number;
  };
}
```

### POST `/api/users/[userId]/follow`
```typescript
interface FollowUserRequest {
  action: 'follow' | 'unfollow';
}

interface FollowUserResponse {
  success: boolean;
  relationship: {
    isFollowing: boolean;
    isFollowedBy: boolean;
    isMutualFollow: boolean;
  };
  followerCount: number;
}
```

### PUT `/api/users/[userId]/profile`
```typescript
interface UpdateProfileRequest {
  username?: string;
  bio?: string;
  socialLinks?: {
    blog?: string;
    twitter?: string;
    instagram?: string;
  };
  privacy?: {
    emailVisible: boolean;
    activityVisible: 'all' | 'followers' | 'none';
    followersVisible: boolean;
  };
}

interface UpdateProfileResponse {
  success: boolean;
  user: UserProfile;
  errors?: Array<{
    field: string;
    message: string;
  }>;
}
```

### POST `/api/users/[userId]/avatar`
```typescript
interface UpdateAvatarRequest {
  image: File;
  cropData?: {
    x: number;
    y: number;
    width: number;
    height: number;
  };
}

interface UpdateAvatarResponse {
  success: boolean;
  profileImage: string;
  sizes: {
    thumbnail: string; // 50x50
    small: string;     // 100x100
    medium: string;    // 200x200
    large: string;     // 400x400
  };
}
```

## ì»´í¬ë„ŒíŠ¸ êµ¬ì¡°

### 1. ProfilePage (ë©”ì¸ ì»´í¬ë„ŒíŠ¸)
```typescript
interface ProfilePageProps {
  userId: string;
}

// ìƒíƒœ ê´€ë¦¬
- user: UserProfile | null
- activeTab: 'reviews' | 'likes' | 'books' | 'followers' | 'following'
- isFollowing: boolean
- isLoading: boolean
- isOwner: boolean
```

### 2. ProfileHeader (í”„ë¡œí•„ í—¤ë”)
```typescript
interface ProfileHeaderProps {
  user: UserProfile;
  relationship?: UserRelationship;
  isOwner: boolean;
  onFollow: () => Promise<void>;
  onEdit: () => void;
}

// í•˜ìœ„ ì»´í¬ë„ŒíŠ¸
- ProfileAvatar: í”„ë¡œí•„ ì‚¬ì§„
- ProfileInfo: ê¸°ë³¸ ì •ë³´
- ProfileStats: í™œë™ í†µê³„
- FollowButton: íŒ”ë¡œìš° ë²„íŠ¼
- EditButton: ìˆ˜ì • ë²„íŠ¼ (ë³¸ì¸ë§Œ)
```

### 3. ProfileTabs (íƒ­ ë„¤ë¹„ê²Œì´ì…˜)
```typescript
interface ProfileTabsProps {
  activeTab: string;
  onTabChange: (tab: string) => void;
  counts: {
    reviews: number;
    likes: number;
    books: number;
    followers: number;
    following: number;
  };
  isOwner: boolean;
}
```

### 4. ProfileContent (íƒ­ ì½˜í…ì¸ )
```typescript
interface ProfileContentProps {
  activeTab: string;
  userId: string;
  isOwner: boolean;
}

// íƒ­ë³„ ì»´í¬ë„ŒíŠ¸
- ReviewsList: ë…í›„ê° ëª©ë¡
- LikedReviewsList: ì¢‹ì•„ìš”í•œ ë…í›„ê° (ë³¸ì¸ë§Œ)
- BooksList: ì„œì¬ (ì½ì€ ì±… ëª©ë¡)
- FollowsList: íŒ”ë¡œì›Œ/íŒ”ë¡œì‰ ëª©ë¡
```

### 5. ProfileEditModal (í”„ë¡œí•„ í¸ì§‘)
```typescript
interface ProfileEditModalProps {
  user: UserProfile;
  isOpen: boolean;
  onClose: () => void;
  onSave: (data: UpdateProfileRequest) => Promise<void>;
}

// í¸ì§‘ ê°€ëŠ¥ í•­ëª©
- ë‹‰ë„¤ì„
- ìê¸°ì†Œê°œ
- ì†Œì…œ ë§í¬
- ê°œì¸ì •ë³´ ê³µê°œ ì„¤ì •
```

### 6. AvatarEditModal (í”„ë¡œí•„ ì‚¬ì§„ í¸ì§‘)
```typescript
interface AvatarEditModalProps {
  currentImage?: string;
  isOpen: boolean;
  onClose: () => void;
  onSave: (file: File, cropData?: CropData) => Promise<void>;
}

// ê¸°ëŠ¥
- ì´ë¯¸ì§€ ì—…ë¡œë“œ (ë“œë˜ê·¸ì•¤ë“œë¡­)
- ì´ë¯¸ì§€ í¬ë¡­
- ë¯¸ë¦¬ë³´ê¸°
- ì—¬ëŸ¬ í¬ê¸° ìë™ ìƒì„±
```

## ìƒíƒœ ê´€ë¦¬ (Zustand)

### ProfileStore
```typescript
interface ProfileState {
  // ìƒíƒœ
  currentProfile: UserProfile | null;
  profileCache: Map<string, UserProfile>; // ì‚¬ìš©ìë³„ ìºì‹œ
  isLoading: boolean;
  error: string | null;
  
  // ì•¡ì…˜
  loadProfile: (userId: string) => Promise<void>;
  followUser: (userId: string) => Promise<void>;
  unfollowUser: (userId: string) => Promise<void>;
  updateProfile: (userId: string, data: UpdateProfileRequest) => Promise<void>;
  updateAvatar: (userId: string, file: File, cropData?: CropData) => Promise<void>;
  
  // ì½˜í…ì¸  ë¡œë”©
  loadUserReviews: (userId: string, options?: UserReviewsRequest) => Promise<ReviewSummary[]>;
  loadUserLikes: (userId: string, options?: UserLikesRequest) => Promise<any[]>;
  loadUserBooks: (userId: string, options?: UserBooksRequest) => Promise<any[]>;
  loadUserFollows: (userId: string, type: 'followers' | 'following') => Promise<any[]>;
  
  // ìœ í‹¸ë¦¬í‹°
  clearProfile: () => void;
  updateFollowStatus: (userId: string, isFollowing: boolean, followerCount: number) => void;
}
```

## íŒ”ë¡œìš° ì‹œìŠ¤í…œ

### íŒ”ë¡œìš° ë²„íŠ¼ ìƒíƒœ ê´€ë¦¬
```typescript
const FollowButton: React.FC<{
  userId: string;
  isFollowing: boolean;
  followerCount: number;
  onFollow: (userId: string) => Promise<void>;
}> = ({ userId, isFollowing, followerCount, onFollow }) => {
  const [isLoading, setIsLoading] = useState(false);
  const [optimisticFollow, setOptimisticFollow] = useState(isFollowing);
  const [optimisticCount, setOptimisticCount] = useState(followerCount);
  
  const handleFollow = async () => {
    setIsLoading(true);
    
    // ë‚™ê´€ì  ì—…ë°ì´íŠ¸
    const newFollowState = !optimisticFollow;
    setOptimisticFollow(newFollowState);
    setOptimisticCount(prev => newFollowState ? prev + 1 : prev - 1);
    
    try {
      await onFollow(userId);
    } catch (error) {
      // ì‹¤íŒ¨ ì‹œ ë¡¤ë°±
      setOptimisticFollow(isFollowing);
      setOptimisticCount(followerCount);
      showError('íŒ”ë¡œìš° ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤');
    } finally {
      setIsLoading(false);
    }
  };
  
  const buttonText = optimisticFollow ? 'ì–¸íŒ”ë¡œìš°' : 'íŒ”ë¡œìš°';
  const buttonStyle = optimisticFollow 
    ? 'bg-gray-200 text-gray-800 hover:bg-gray-300' 
    : 'bg-blue-600 text-white hover:bg-blue-700';
  
  return (
    <button
      onClick={handleFollow}
      disabled={isLoading}
      className={`px-4 py-2 rounded-lg font-medium transition-colors ${buttonStyle}`}
    >
      {isLoading ? 'ì²˜ë¦¬ì¤‘...' : buttonText}
    </button>
  );
};
```

### ìƒí˜¸ íŒ”ë¡œìš° ê°ì§€
```typescript
const MutualFollowBadge: React.FC<{
  relationship: UserRelationship;
}> = ({ relationship }) => {
  if (!relationship.isMutualFollow) return null;
  
  return (
    <span className="inline-flex items-center px-2 py-1 rounded-full text-xs bg-green-100 text-green-800">
      <svg className="w-3 h-3 mr-1" fill="currentColor" viewBox="0 0 20 20">
        <path d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
      </svg>
      ì„œë¡œ íŒ”ë¡œìš°
    </span>
  );
};
```

## í”„ë¡œí•„ í¸ì§‘ ì‹œìŠ¤í…œ

### ë‹‰ë„¤ì„ ì¤‘ë³µ í™•ì¸
```typescript
const useUsernameValidation = (currentUsername: string) => {
  const [isChecking, setIsChecking] = useState(false);
  const [isAvailable, setIsAvailable] = useState<boolean | null>(null);
  const [message, setMessage] = useState('');
  
  const checkUsername = useCallback(
    debounce(async (username: string) => {
      if (username === currentUsername) {
        setIsAvailable(true);
        setMessage('í˜„ì¬ ë‹‰ë„¤ì„ì…ë‹ˆë‹¤');
        return;
      }
      
      if (username.length < 2) {
        setIsAvailable(false);
        setMessage('ìµœì†Œ 2ì ì´ìƒ ì…ë ¥í•´ì£¼ì„¸ìš”');
        return;
      }
      
      setIsChecking(true);
      try {
        const result = await api.checkUsernameAvailability(username);
        setIsAvailable(result.available);
        setMessage(result.available ? 'ì‚¬ìš© ê°€ëŠ¥í•œ ë‹‰ë„¤ì„ì…ë‹ˆë‹¤' : 'ì´ë¯¸ ì‚¬ìš© ì¤‘ì¸ ë‹‰ë„¤ì„ì…ë‹ˆë‹¤');
      } catch (error) {
        setIsAvailable(null);
        setMessage('í™•ì¸ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤');
      } finally {
        setIsChecking(false);
      }
    }, 500),
    [currentUsername]
  );
  
  return { isChecking, isAvailable, message, checkUsername };
};
```

### í”„ë¡œí•„ ì‚¬ì§„ í¬ë¡­
```typescript
const AvatarCropper: React.FC<{
  imageFile: File;
  onCropComplete: (croppedImage: File, cropData: CropData) => void;
}> = ({ imageFile, onCropComplete }) => {
  const [crop, setCrop] = useState<CropData>({
    x: 0,
    y: 0,
    width: 200,
    height: 200
  });
  
  const [imageSrc, setImageSrc] = useState<string>('');
  
  useEffect(() => {
    const reader = new FileReader();
    reader.onload = () => setImageSrc(reader.result as string);
    reader.readAsDataURL(imageFile);
  }, [imageFile]);
  
  const handleCropComplete = async () => {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const image = new Image();
    
    image.onload = () => {
      canvas.width = crop.width;
      canvas.height = crop.height;
      
      ctx?.drawImage(
        image,
        crop.x, crop.y, crop.width, crop.height,
        0, 0, crop.width, crop.height
      );
      
      canvas.toBlob((blob) => {
        if (blob) {
          const croppedFile = new File([blob], 'avatar.jpg', { type: 'image/jpeg' });
          onCropComplete(croppedFile, crop);
        }
      }, 'image/jpeg', 0.9);
    };
    
    image.src = imageSrc;
  };
  
  return (
    <div className="space-y-4">
      <ReactCrop
        crop={crop}
        onChange={setCrop}
        aspect={1} // ì •ì‚¬ê°í˜• ë¹„ìœ¨
      >
        <img src={imageSrc} alt="Crop preview" />
      </ReactCrop>
      
      <button
        onClick={handleCropComplete}
        className="w-full px-4 py-2 bg-blue-600 text-white rounded-lg"
      >
        í¬ë¡­ ì™„ë£Œ
      </button>
    </div>
  );
};
```

## ë°°ì§€ ì‹œìŠ¤í…œ

### ë°°ì§€ ì¢…ë¥˜ ë° ì¡°ê±´
```typescript
interface Badge {
  id: string;
  name: string;
  description: string;
  icon: string;
  condition: BadgeCondition;
  tier: 'bronze' | 'silver' | 'gold' | 'platinum';
}

interface BadgeCondition {
  type: 'review_count' | 'likes_received' | 'streak_days' | 'books_read';
  threshold: number;
}

const BADGES: Badge[] = [
  {
    id: 'first_review',
    name: 'ì²« ë…í›„ê°',
    description: 'ì²« ë²ˆì§¸ ë…í›„ê°ì„ ì‘ì„±í–ˆìŠµë‹ˆë‹¤',
    icon: 'ğŸ“',
    condition: { type: 'review_count', threshold: 1 },
    tier: 'bronze'
  },
  {
    id: 'reviewer_10',
    name: 'ë¦¬ë·°ì–´',
    description: 'ë…í›„ê° 10ê°œë¥¼ ì‘ì„±í–ˆìŠµë‹ˆë‹¤',
    icon: 'ğŸ“š',
    condition: { type: 'review_count', threshold: 10 },
    tier: 'silver'
  },
  {
    id: 'popular_writer',
    name: 'ì¸ê¸° ì‘ê°€',
    description: 'ì¢‹ì•„ìš” 100ê°œë¥¼ ë°›ì•˜ìŠµë‹ˆë‹¤',
    icon: 'â­',
    condition: { type: 'likes_received', threshold: 100 },
    tier: 'gold'
  },
  {
    id: 'bookworm',
    name: 'ì±…ë²Œë ˆ',
    description: '100ê¶Œì˜ ì±…ì„ ì½ì—ˆìŠµë‹ˆë‹¤',
    icon: 'ğŸ›',
    condition: { type: 'books_read', threshold: 100 },
    tier: 'platinum'
  }
];

const checkBadgeEligibility = (userStats: UserStats): Badge[] => {
  return BADGES.filter(badge => {
    switch (badge.condition.type) {
      case 'review_count':
        return userStats.reviewCount >= badge.condition.threshold;
      case 'likes_received':
        return userStats.likesReceived >= badge.condition.threshold;
      case 'books_read':
        return userStats.booksRead >= badge.condition.threshold;
      case 'streak_days':
        return userStats.streakDays >= badge.condition.threshold;
      default:
        return false;
    }
  });
};
```

## ê°œì¸ì •ë³´ ë³´í˜¸

### ê³µê°œ ë²”ìœ„ ì„¤ì •
```typescript
interface PrivacySettings {
  emailVisible: boolean; // ì´ë©”ì¼ ì£¼ì†Œ ê³µê°œ
  activityVisible: 'all' | 'followers' | 'none'; // í™œë™ ë‚´ì—­ ê³µê°œ ë²”ìœ„
  followersVisible: boolean; // íŒ”ë¡œì›Œ ëª©ë¡ ê³µê°œ
  likesVisible: 'all' | 'followers' | 'none'; // ì¢‹ì•„ìš”í•œ ë…í›„ê° ê³µê°œ ë²”ìœ„
}

const PrivacySettingsForm: React.FC<{
  settings: PrivacySettings;
  onSave: (settings: PrivacySettings) => void;
}> = ({ settings, onSave }) => {
  const [formData, setFormData] = useState(settings);
  
  return (
    <div className="space-y-6">
      <div>
        <h3 className="text-lg font-medium">ê°œì¸ì •ë³´ ê³µê°œ ì„¤ì •</h3>
        <p className="text-gray-600">ë‹¤ë¥¸ ì‚¬ìš©ìì—ê²Œ ê³µê°œí•  ì •ë³´ë¥¼ ì„ íƒí•˜ì„¸ìš”</p>
      </div>
      
      <div className="space-y-4">
        <div className="flex items-center justify-between">
          <div>
            <label className="font-medium">ì´ë©”ì¼ ì£¼ì†Œ</label>
            <p className="text-sm text-gray-600">í”„ë¡œí•„ì—ì„œ ì´ë©”ì¼ ì£¼ì†Œ í‘œì‹œ</p>
          </div>
          <input
            type="checkbox"
            checked={formData.emailVisible}
            onChange={(e) => setFormData({
              ...formData,
              emailVisible: e.target.checked
            })}
          />
        </div>
        
        <div>
          <label className="font-medium">í™œë™ ë‚´ì—­ ê³µê°œ ë²”ìœ„</label>
          <p className="text-sm text-gray-600">ë…í›„ê°, ëŒ“ê¸€ ë“±ì˜ í™œë™ ë‚´ì—­</p>
          <select
            value={formData.activityVisible}
            onChange={(e) => setFormData({
              ...formData,
              activityVisible: e.target.value as 'all' | 'followers' | 'none'
            })}
            className="mt-2 block w-full rounded-md border-gray-300"
          >
            <option value="all">ì „ì²´ ê³µê°œ</option>
            <option value="followers">íŒ”ë¡œì›Œë§Œ</option>
            <option value="none">ë¹„ê³µê°œ</option>
          </select>
        </div>
      </div>
      
      <button
        onClick={() => onSave(formData)}
        className="w-full px-4 py-2 bg-blue-600 text-white rounded-lg"
      >
        ì„¤ì • ì €ì¥
      </button>
    </div>
  );
};
```

## ì„±ëŠ¥ ìµœì í™”

### ë¬´í•œ ìŠ¤í¬ë¡¤ êµ¬í˜„
```typescript
const useInfiniteUserContent = <T>(
  userId: string,
  contentType: 'reviews' | 'likes' | 'books' | 'followers' | 'following',
  options?: any
) => {
  const [items, setItems] = useState<T[]>([]);
  const [hasMore, setHasMore] = useState(true);
  const [isLoading, setIsLoading] = useState(false);
  const [cursor, setCursor] = useState<string>();
  
  const loadMore = useCallback(async () => {
    if (isLoading || !hasMore) return;
    
    setIsLoading(true);
    try {
      const response = await api.getUserContent(userId, contentType, {
        ...options,
        cursor
      });
      
      setItems(prev => [...prev, ...response.items]);
      setCursor(response.pagination.nextCursor);
      setHasMore(response.pagination.hasMore);
    } catch (error) {
      console.error('Failed to load user content:', error);
    } finally {
      setIsLoading(false);
    }
  }, [userId, contentType, cursor, isLoading, hasMore, options]);
  
  // ì´ˆê¸° ë¡œë“œ
  useEffect(() => {
    setItems([]);
    setCursor(undefined);
    setHasMore(true);
    loadMore();
  }, [userId, contentType]);
  
  return { items, hasMore, isLoading, loadMore };
};
```

## ì—ëŸ¬ ì²˜ë¦¬

### í”„ë¡œí•„ ì ‘ê·¼ ê¶Œí•œ ì²˜ë¦¬
```typescript
const ProfileAccessGuard: React.FC<{
  user: UserProfile;
  currentUser?: User;
  children: React.ReactNode;
  fallback?: React.ReactNode;
}> = ({ user, currentUser, children, fallback }) => {
  // ë³¸ì¸ í”„ë¡œí•„ì´ê±°ë‚˜ ê³µê°œ í”„ë¡œí•„ì¸ ê²½ìš°
  if (currentUser?.id === user.id || user.privacy.activityVisible === 'all') {
    return <>{children}</>;
  }
  
  // íŒ”ë¡œì›Œë§Œ ê³µê°œì´ê³  íŒ”ë¡œì›Œì¸ ê²½ìš°
  if (user.privacy.activityVisible === 'followers' && 
      user.relationship?.isFollowedBy) {
    return <>{children}</>;
  }
  
  // ì ‘ê·¼ ê¶Œí•œ ì—†ìŒ
  return fallback || (
    <div className="text-center py-8">
      <p className="text-gray-600">ë¹„ê³µê°œ í”„ë¡œí•„ì…ë‹ˆë‹¤</p>
    </div>
  );
};
```

## ì ‘ê·¼ì„±

### ìŠ¤í¬ë¦° ë¦¬ë” ì§€ì›
```typescript
// ARIA ë¼ë²¨ë§
<section role="main" aria-labelledby="profile-title">
  <h1 id="profile-title" className="sr-only">
    {user.username}ë‹˜ì˜ í”„ë¡œí•„
  </h1>
  
  <div role="tablist" aria-label="í”„ë¡œí•„ ì½˜í…ì¸ ">
    <button
      role="tab"
      aria-selected={activeTab === 'reviews'}
      aria-controls="reviews-panel"
      id="reviews-tab"
    >
      ë…í›„ê° {reviewCount}ê°œ
    </button>
  </div>
  
  <div
    role="tabpanel"
    id="reviews-panel"
    aria-labelledby="reviews-tab"
    hidden={activeTab !== 'reviews'}
  >
    {/* ë…í›„ê° ëª©ë¡ */}
  </div>
</section>
```

## ì„±ëŠ¥ ëª©í‘œ

### Core Web Vitals
- **LCP**: < 2.5ì´ˆ (í”„ë¡œí•„ ì •ë³´ ë¡œë”©)
- **FID**: < 100ms (íƒ­ ì „í™˜, íŒ”ë¡œìš° ë²„íŠ¼)
- **CLS**: < 0.1 (ì½˜í…ì¸  ë¡œë”© ì‹œ ë ˆì´ì•„ì›ƒ ë³€ê²½ ìµœì†Œí™”)

### ì‚¬ìš©ì ê²½í—˜ ì§€í‘œ
- í”„ë¡œí•„ ì´ˆê¸° ë¡œë”©: < 1.5ì´ˆ
- íŒ”ë¡œìš° ë²„íŠ¼ ì‘ë‹µ: < 500ms
- íƒ­ ì „í™˜: < 300ms
- ë¬´í•œ ìŠ¤í¬ë¡¤ ë¡œë”©: < 1ì´ˆ